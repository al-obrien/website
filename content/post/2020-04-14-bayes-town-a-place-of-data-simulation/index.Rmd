---
title: 'Bayes'' Town: A place of data simulation'
author: al-obrien
date: '2020-07-14'
slug: bayes-town-a-place-of-data-simulation
categories: []
tags:
  - R
  - bayesian
  - simulation
subtitle: ''
summary: ''
authors: [al-obrien]
lastmod: '2020-07-14T10:27:06-06:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: yes
projects: []
draft: true
---

```{r, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}
knitr::opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE, echo = TRUE)
```

```{r setup, include = FALSE}

# ------------------ #
# Required libraries
# ------------------ #
library(R6)
library(rjags)


# ------------------ #
# Create class for simulation

# Alternatives would be S3 or S4, which
# have their own merits too, but many users
# will find R6 more intuitive if coming from other OOP 
# languages.
# ------------------ #

# Create class, using UpperCamelCase convention
BayesTown <- R6Class('BayesTown', list(
  
  # Public variables
  population_size = NA,
  jags_model = NULL,
  jags_parameters = NA,
  model_location = NULL,
  n.iter = NULL,
  data = NULL,
  mcmclist = NULL,
  varnames = NULL,
  
  
  # Public methods
  # Create samples from this dataset
  resample = function(...){
    
   # temp <- if(exists(n.chains)) {round(self$population_size/n.chains, 0)} else {self$population_size}
    
    cat('\n----------------- SAMPLING ', self$population_size, ' times -----------------\n')
    data = rjags::coda.samples(model = self$jags_model,
                               variable.names = self$varnames, 
                               n.iter = round(self$population_size/self$jags_model$nchain(), 0))
    dataOut = purrr::map_df(data, ~rbind(as.data.frame(.)))
    self$data <- dataOut
    self$mcmclist <- data
    
    # Print sample of the data
    cat('Data sample: \n')
    print.data.frame(head(self$data))
    
    invisible(self)
  },
  
  # Allow to have jags_model to be a string or a file
  # Let sampling occur right away
  initialize = function(population_size, jags_model, jags_data, n.iter = 5000, ...) {
    
    # Check conditions
    stopifnot(file.exists(jags_model)|is.character(jags_model))
    stopifnot(is.numeric(population_size), length(population_size) ==1)
    
    if(is.character(jags_model)){
      
      # Make tempfile for model
      temp_loc <- tempfile()
      sink(temp_loc)
      cat(jags_model)
      sink()
      
    } else if (file.exists(jags_model)) {
      
      temp_loc <- file.path(jags_model)
      
    }
    
    # Assign the self values
    self$n.iter <- n.iter
    self$population_size <- population_size
    self$jags_model <- rjags::jags.model(temp_loc, jags_data, ...)
    self$varnames <- variable.names(self$jags_model)
    
    cat('\n-------------- BURNING IN ', self$n.iter, ' iterations --------------\n')
    rjags:::update.jags(object = self$jags_model, n.iter = self$n.iter)
    self$model_location <- temp_loc
    
    # Data sample (this is first one, so not really a sample)
    self$resample()
    
  },
  
  # Method to output key information about the sample
  print = function(...){
    cat('-------------------- MODEL OVERVIEW --------------------\n')
    cat('Model Location: ', self$model_location, '\n')
    cat('MCMC burn-in iterations: ', self$n.iter, '\n')
    cat('JAGS Model: ', self$jags_model$model(), sep = '\n')
    cat('\n-------------------- SAMPLE DATA --------------------\n')
    cat('Population Size: ', self$population_size, '\n')
    cat('Sample data: \n')
    print.data.frame(head(self$data, 10))
    invisible(self)
  },
  
  # Method to extract JAGS model (needs to be in 'mcmc' form to work with coda)
  summary = function(...){
    cat('--------------- SUMMARY DATA ---------------')
    summary(self$mcmclist)
  },
  
  # Set variables (will help to do re-sampling easier)
  set_variables = function(varnames = variable.names(self$jags_model), mode = 'include'){
    stopifnot(is.character(varnames), all(varnames %in% variable.names(self$jags_model)))
    stopifnot(mode %in% c('exclude', 'include'))
    
    if(mode == 'exclude'){
      allvars <- variable.names(self$jags_model)
      keep_only <- allvars[!(allvars %in% varnames)]
      cat(keep_only)
      self$varnames <- keep_only
      cat('Variables of interest set to: ', paste(self$varnames, collapse = ', '))
      
    } else if (mode == 'include'){
      self$varnames <- varnames
      cat('Variables of interest set to: ', paste(self$varnames, collapse = ', '))
    }
    
    invisible(self)
  },
  
  # Plot diagnostics (convenience wrapper around coda)
  plot = function(type = 'trace', ...){
    stopifnot(type %in% c('trace', 'gelman', 'geweke', 'autocorr'))
    
    for(i in unique(type)){
      switch(i,
             'trace' = coda::traceplot(self$mcmclist, ...),
             'gelman' = coda::gelman.plot(self$mcmclist, ...),
             'geweke' =  coda::geweke.plot(self$mcmclist, ...),
             'autocorr' = coda::autocorr.plot(self$mcmclist, ...))
    }
  }
))

```


## Welcome to Bayes' Town

Bayes' Town is a special place, a place where we can be omnipotent and omniscient. We take comfort in having knowledge and control of all things, even though we know the entire place is apart from reality, a muddled reflection at best and a complete fantasy at worst. Bayes' Town is a simulation, a useful tool we can use to explore scenarios and test hypotheses, based in reality or otherwise.

For public health, creating a synthetic population can be a valuable tool. Population characteristics, and relations between them, can be modeled based upon prior knowledge or to understand 'what-if' scenarios. Sometimes, it even is just a good way to better understand how a model is working. If you know the generative process of a synthetic population, then you can see how well certain models perform under those circumstances. More on this later...

As we are the masters of our simulated domain, we can decide exactly how the characteristics of our Bayes' Town citizens are connected. Citizens of Bayes' Town are very concerned about disease, specifically the rampant *Disease X*. Fortunately for us as the creators, we can instantly summon the image of how the population is impacted by this pestilence. We can visualize the relationship as an network between variables of *sex*, *age*, and whether or not the individual lives in an *urban or rural* location. Using [`DiagrammeR`](https://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html) and the `DOT` language, we can visualize this relationship. 

```{r echo = FALSE, collapse = T, fig.cap = 'The "known" relationship between Disease X and the citizens of Bayes\' Town.', out.height = '100%', out.width = "100%"}
library(DiagrammeR)

DiagrammeR::grViz("digraph {
  
  # Set graph
  graph [layout = dot, rankdir = TB]
  
  # Nodes overall
  node [shape = oval, style = filled, fontcolor = '#394045']  
  
  # Explanatory nodes
  node [fillcolor = '#5cb8ff', color = '#3f82b5']  
  sex [label = 'Sex']
  age [label = 'Age']
  urb [label =  'Urban/Rural']
  
  # Outcome node
  node [fillcolor = '#ffc15e', color = '#c99747']
  disease [label = 'Disease X']
  
  # Edges
  edge [color = '#848c91']
  sex -> age
  {sex urb age} -> disease
  }")
```
    
With this knowledge, we can generate data on our citizens for this particular scenario. The core functionality is powered by `rJAGS` but to make it a bit easier to use, the process is wrapped up into an `R6` object called `BayesTown`. This should be familiar to anyone from object-orientated programming (OOP) languages like Python but perhaps a bit foreign for those more comfortable with multiple dispatch, which is the common approach in R (`S3` and `S4`) and Julia. To create a population of 1,000 people we provide some predefined information to the `new` (construct) method. 

```{r include = FALSE}
# Example inputs
inputParam <- list(p_sex = 0.52, 
                   age_shape = 6,
                   age_scale = 6,
                   b_age = 0.7)

simModel <-  as.character('
                      model {
                      sex ~ dbinom(p_sex, 1);
                      urbanRural ~ dbinom(0.8, 1);
                      age ~ dgamma((age_shape+b_age*sex), 1/age_scale);
                      a_d ~ dnorm(-10, 10);
                      b1_d ~ dnorm(.015, 10);
                      b2_d ~ dnorm(.005, 10);
                      b3_d ~ dnorm(5, 10);
                      logit(p) <- a_d + b1_d * age + b2_d * sex + b3_d * urbanRural;
                      disease ~ dbinom(p, 1);
                      }')
```

```{r results = FALSE}
newTown <- BayesTown$new(population_size = 1000,
                      jags_data = inputParam, 
                      n.chains = 2,
                      n.iter = 5000,
                      jags_model = simModel)
```
The output provides some basic information on the model graph and a snapshot of the data sample. This includes all the information from the simulation, including the various coefficients and distribution parameters. However, since we are currently only interested in the variables from the diagram above right now, we can extract just those. This is easily done by *method chaining* `set_variables` (to sample only particular variables/parameters) and `resample` (to rerun the simulation).

```{r results = FALSE}
# Import library for some exploration work
library(dplyr)

# Data sample just to include the set of variables in the list
newTown$set_variables(c('age', 'sex', 'urbanRural', 'disease'), mode = 'include')$resample()

# Output first 5 rows of simulated data
head(newTown$data, 5)

# Summarize some basic information using dplyr
newTown$data %>% 
  group_by(sex, urbanRural) %>%
  summarise(meanAge = mean(age),
            diseasePerc = 100 * (sum(disease)/nrow(.)))
```

```{r echo = FALSE, results = TRUE}
head(newTown$data, 10)
newTown$data %>% group_by(sex, urbanRural) %>% summarise(meanAge = mean(age), diseasePerc = 100 * (sum(disease)/nrow(.))) 
```

Just from this basic summary, we can see that (a) living in urban areas has a large influence on disease status, (b) females and older ages on average have a slightly higher proportion of disease. Tables are nice, but pictures are better. Let's create a few plots to see how the Bayes' Town citizen characteristics relate to their disease status.

```{r style}
theme_eD <- function() {
  theme_minimal() %+replace%
  theme(
    panel.grid.major.x = element_blank(),
    axis.title = element_text(face = 'bold'),
    legend.position = 'top',
    legend.title = element_blank(),
    legend.key.size = unit(2, 'line')
  )
}
  
```


```{r}
# Load plotting library
library(ggplot2)

# Minor adjustment to data for plotting
plotData <- newTown$data %>% 
  mutate(sex = if_else(sex == 1, 'Female', 'Male'),
         age = floor(age))

# Age-Sex distribution
ggplot(plotData) +
  geom_boxplot(aes(x = sex, y = age, fill = sex),
               outlier.fill = NULL, 
               outlier.shape = 21, 
               width = 0.5) +
  xlab('Sex') +
  ylab('Age') +
  theme_eD() +
  scale_fill_manual(values = c('Male' = '#5cb8ff',
                               'Female' = '#ff8fb7'))

# Disease by age, sex, urban

```


    
    ```{r example}

# Example
inputParam <- list(p_sex = 0.52, 
                   age_shape = 6,
                   age_scale = 6,
                   b_age = 0.7)

simModel <-  as.character('
                      model {
                      sex ~ dbinom(p_sex, 1);
                      urbanRural ~ dbinom(0.8, 1);
                      age ~ dgamma((age_shape+b_age*sex), 1/age_scale);
                      a_d ~ dnorm(-10, 10);
                      b1_d ~ dnorm(.015, 10);
                      b2_d ~ dnorm(.005, 10);
                      b3_d ~ dnorm(5, 10);
                      logit(p) <- a_d + b1_d * age + b2_d * sex + b3_d * urbanRural;
                      disease ~ dbinom(p, 1);
                      }')
simModel2 <- 'model {
disease ~ dbinom(p, 1);
logit(p) <- a_d + b1_d * age + b2_d * sex + b3_d * urbanRural;
sex ~ dbinom(.52, 1);
urbanRural ~ dbinom(0.8, 1);
age ~ dgamma((6+.7*sex), 1/6);
a_d ~ dnorm(-10, 10);
b1_d ~ dnorm(.015, 10);
b2_d ~ dnorm(.005, 10);
b3_d ~ dnorm(5, 10);
}'

newTown <- BayesTown$new(population_size = 1000,
                      jags_data = inputParam, 
                      n.chains = 2,
                      n.iter = 5000,
                      jags_model = simModel)
newTown2 <- BayesTown$new(population_size = 1000,
                         jags_data = NULL, 
                         n.chains = 2,
                         n.iter = 5000,
                         jags_model = simModel2)

newTown$set_variables(names(inputParam), mode = 'exclude')
newTown$resample()
newTown$plot()
newTown$set_variables('sex', mode = 'include')
newTown$resample()
newTown$plot()

newTown$set_variables(c('age', 'sex', 'urbanRural', 'disease'), mode = 'include')
newTown$resample()
mydata <- newTown$data
mean(mydata$age)
prop.table(table(mydata$urbanRural, mydata$disease), margin = 1)

plot(newTown$set_variables('b3_d')$resample())


```
    
    
    
    
    
    
(describe the overall method here)
I used a method of bayesian networks and my belief of the network to create this. The tools 
used are diverse and can be a challenge to start with. But the ability to create your own town and simulate datasets is a 
valuable tool. So, lets get into the details

IF this is all you need to know, then that fine, the rest go through the use case and detaisl!

I plan to use this or similar methods for 'quick' examples where it may be troublesome to get actual datasets. But will explore with others too. More discussion below.



## A case for simulated data

- Access to data in the public domain has become easier over time. This has become a bit hand-in-hand with the big data age ....
- HOwever, usually this data becomes highly aggregated, or linkage to other datasets are difficult.
- This is even more challenging with sensitive data types, such as health. There are some sources available:
- This is even more so with infectious diseases
- Usually involves a data sharing agreement with the group...

However,being in the bizz... I always want more, and usually these datasets do not do much to satisfy. They rarely give the key data for even descriptive epi, names person, place and time. Obvioulsy if we had all of this, the data would be quite identifiable, especially if place is postal code, time is day, and person is all their demographics. Usually this means the data is quite lacking... and uninteresting

  EXAMPLE OF SUPER BASIC SIMULATION TO SHOW HOW EASY... but we want to do more... and more complex like ABM will be for future post

We can do a lot of great things with this, even more when we partner with the data curators. But, sometimes we just want data to be simluaated to show some basic principles and practice with some new coding methods.

## The simulation toolbox

So what to do... well, we can simulate. How? There are a multitude of ways, with varying complexity. There are agent/individual-based models, using tools such as [NetLogo](https://ccl.northwestern.edu/netlogo/), assigning random variables to representative probaiblity distribtuions, creating bayesian networks based upon priors, bayesian netowrks from data. Some of these are availble in packages in R already. NetLogo has a connection to R but requries knowing how to use NetLogo. YOu can also make your own simulation with some knowhow, within R coding itself. The is the Greta, Stan, HydeNet, and simluation packages. Each of these have a balance between flexibility and complexity. 

Most packages may limit what you can do by only allowing certain types of data and node types adn the relationships that can exist between them. By using more 'low-level' packages, for mathematical modelling, and MCMC, there is more freedom in the relationships you can assign. of course, the learning curve is steeper too! Manyt methods rely on having data and dont allow just prior to be set.

I am partial to bayesian methods, as I find them intutiive through their diagrams, and they can be created through imagiation or based upon data. Both of which is good for our purposes.


## Bayesian network data simulation using prior

I wanted a method where I wouldnt need any data if I didnt have it. Short of learning mathematical modelling and agent simulation, I thought I would lean on my knowledge of probability distribution and bayesian approaches. 

Prob distribution alone are quite powerful and have a very straightforward implemetnation in R to create/sample data. But they are not great at allowing one to define the realtionship between the random variables. For this, having a network of connections between the random variables provides a sturcutre that we can understand and test. Since we can also used just our belief based upon distirbutions without data to 'update' our estimates, it is a viable way to create a fake dataset, even though it may not be the preferred choice in practice for a number of reasons, no excluding the obvious one of a priori biases. For a more robust implementation, for a latter post, agent based simulations provide other altnetaives with some success (https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0208775). 

With this knowledge in hand, I can create a simulated town. For now, it is just a snapshot, but dynamic BNs would allow for the dimension of time to be added.

What is MCMC?! It demands attention, but not here. It is a tool I am using to create the datasets from the prob dist.
The heart of the model is code used to create the probability distributions. There are a number of software that can sample from a proability distribution, a popular one being hamiltonian monte carlo impletnations in STAN. However, I found the code in JAGS (an implemetation of the Gibbs sampler) more appraochable, similar to R syntax and relativelyt consise. For my purposes, it worked well. There are a number of packages that make STAN more approachble, but since I wanted all the flexiblity exposed, JAGS provided this quite well. Each MCM implemation has a tradeoff, and for my purposes, although I could have implemented it in STAN, I preferred how RJAGS worked. Since the network was a hybrid network, I found that there was not many resources to learn from and so the examples I could find often used JAGS. There are even several JAGS implementations in R... I used rjags as it was created by the creator of JAGS Martyn Plummer using the BUGS language syntax

DEFINE< COMPILE<SIMUALTE

Although I could use the rjags functions directly, which could be completed in a few steps, I wanted to hide myself from the extra code, most of which would not need to be touched much. So I encapsulated it within a class using R6 package. This allowed me to focus more on what the output is, rather than on all the functions that are needed to create the data. Although I still need to know it, I can have a layer of abstraction once compelted to ensure that I have logical names specific to making Bayes town... this makes it so i can have specific operations on the data, without having to use rjags directly anymore than I have to. Of course, anythign custom I may need to delve into the code and class. But since Im using MCMC as a tool, its find that I have my class focused on what hte data output is and the diagnostics for it.

Based upon image 1... I need to define how all the random variables interact...

In statistics lingo, this looks like this...
prior predictive simulation....

\begin{align*}
& \textbf{Likelihood function}\,\text{(for prior predictive simulation)}\\
& disease \sim Binom(p, 1) \\
& logit(p) = a_{disease} + b_1(age) + b_2(sex) + b_3(urbanRural) \\\\

& \textbf{Random variable priors}\\
& sex \sim  Binom(propMale, 1) \\ 
& urbanRural \sim Binom(0.8, 1) \\
& age \sim Gamma((shape+paramter\_age*sex), 1/agescale) \\ \\

& \textbf{Parameter priors}\\
& a_{disease} \sim Normal(-10, 10) \\
& b_{1} \sim Normal(0.015, 10) \\
& b_{2} \sim Normal(0.005, 10) \\
& b_{3} \sim Normal(5, 10) \\ \\ 
\end{align*}

product of liklihood and the prior to get postieror... sometimes closed form soluation doesnt exist and need to approxiatme it using MCMC methods.

When converted to R, we see an RJAGS model like so.
Normally, RJAGS will require a loop, where the data input is placed. But since I am only using prior, it will look like this without the for loop, like this which is defining the likelihood. BUt i only want the priors.

{    for ( i in 1:N ) {
    
    P[i] <- 1/V[i]
    
    y[i] ~ dnorm( d, P[i] )

    }

```{r echo=TRUE, eval=FALSE}
bayesTownModel <- 'model {
disease ~ dbinom(p, 1);
logit(p) <- a + b1 * age + b2 * sex + b3 * urbanRural;

sex ~ dbinom(.52, 1);
urbanRural ~ dbinom(0.8, 1);
age ~ dgamma((6+.7*sex), 1/6);

a ~ dnorm(-10, 10);
b1 ~ dnorm(.015, 10);
b2 ~ dnorm(.005, 10);
b3 ~ dnorm(5, 10);
}'
```


simModel <-  '
                      model {
                      sex ~ dbinom(p_sex, 1);
                      urbanRural ~ dbinom(0.8, 1);
                      age ~ dgamma((age_shape+b_age*sex), 1/age_scale);
                      a_d ~ dnorm(-10, 10);
                      b1_d ~ dnorm(.015, 10);
                      b2_d ~ dnorm(.005, 10);
                      b3_d ~ dnorm(5, 10);
                      logit(p) <- a_d + b1_d * age + b2_d * sex + b3_d * urbanRural;
                      disease ~ dbinom(p, 1);
                      }'
               textConnection()       

I then set some input parameters. These are my beliefs on what the proprtion of the sex distribution is, and the relationship between age and sex. The rest I have already just coded directly into the model itself, but I know I may want these ones changed and allowing for some input parameters, will allow me to provide data to this function int he future as well...

<!-- inputParam <- list(p_sex = 0.52,  -->
<!--                    age_shape = 6, -->
<!--                    age_scale = 6, -->
<!--                    b_age = 0.7) -->

Then we setup the model

newTown2 <- BayesTown$new(population_size = 1000,
                         jags_data = NULL, 
                         n.chains = 2,
                         n.iter = 5000,
                         jags_model = simModel2)
                   

## Appendix

### Data sources
1. Kaggle https://www.kaggle.com/tags/healthcare 
1. WHO https://apps.who.int/gho/data/node.resources
1. https://www.data.gov/
1. CDC https://wonder.cdc.gov/Welcome.html
1. NHS data catalogue https://data.england.nhs.uk/dataset
1. Alberta open datasets http://www.ahw.gov.ab.ca/IHDA_Retrieval/
1. Canada open data https://open.canada.ca/en/open-data 
1. https://perma.cc/M3XC-M9HU

### Simulation method
1. NetLogo: https://ccl.northwestern.edu/netlogo/  and RNetLogo https://rdrr.io/cran/RNetLogo/man/RNetLogo-package.html
1. Simulation R https://www.rdatagen.net/page/simstudy/
1. Useful blog on starting data simulation with probability distributions https://aosmith.rbind.io/2018/08/29/getting-started-simulating-data/ 
1. Mathematical modelling appraoch https://www.epimodel.org/ 
1. HydeNet https://cran.r-project.org/web/packages/HydeNet/index.html and bnlearn https://www.bnlearn.com/ Bayesian simluation ; bayesvl
https://github.com/sshpa/bayesvl  https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3469457

### Bayesian statistics

While there are many blogs and online articles about bayesian statistics and bayesian networks; I found some actualy books were my best resource; both are enjoyable and worth the price tag.
1. https://xcelab.net/rm/statistical-rethinking/  and https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/featured
1. https://www.routledge.com/Bayesian-Networks-With-Examples-in-R/Scutari-Denis/p/book/9781482225587
1. https://www.aaai.org/ojs/index.php/aimagazine/article/view/918
